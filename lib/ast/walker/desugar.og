!walker

import
	fmt
	bytes
	strings
	"encoding/gob"
	"github.com/champii/og/lib/ast"

struct Template
	Name    string
	Types   []string
	UsedFor [][]string
	Node    ast.INode

struct GobRegister
	AstWalker
	*Each(n ast.INode) -> gob.Register(n)

RunGobRegister(tree ast.INode) ->
	p := GobRegister{}
	gob.Register(tree)
	p.type_ = &p
	p.Walk(tree)

struct Templates
	names     []string
	templates []*Template

	*Add(name string, template *Template) ->
		@names = append(@names, name)
		@templates = append(@templates, template)

	Get(name string): *Template ->
		for i, n in @names
			if n == name
				return @templates[i]

		return nil

struct Desugar
	AstWalker
	root      ast.INode
	Templates Templates

	*GenerateStruct(template *Template) ->
		source := @root.(*ast.SourceFile)

		for _, usedFor in template.UsedFor
			other := &ast.StructType{}

			var buf bytes.Buffer
			enc := gob.NewEncoder(&buf)
			if err := enc.Encode(template.Node.(*ast.StructType)); err != nil
				fmt.Println("ERROR ENCODE", err)

			dec := gob.NewDecoder(&buf)
			if err := dec.Decode(&other); err != nil
				fmt.Println("ERROR DECODE", err)

			newStruct := RunTemplateGen(other, template.Types, usedFor).(*ast.StructType)

			newStruct.Name += strings.Join(usedFor, "")

			topLevel := &ast.TopLevel
				Declaration: &ast.Declaration
					TypeDecl: &ast.TypeDecl
						StructType: newStruct

			source.TopLevels = append(source.TopLevels, topLevel)

	*GenerateTopFns(template *Template) ->
		source := @root.(*ast.SourceFile)

		for _, usedFor in template.UsedFor
			other := &ast.FunctionDecl{}

			var buf bytes.Buffer
			enc := gob.NewEncoder(&buf)
			if err := enc.Encode(template.Node.(*ast.FunctionDecl)); err != nil
				fmt.Println("ERROR ENCODE", err)

			dec := gob.NewDecoder(&buf)
			if err := dec.Decode(&other); err != nil
				fmt.Println("ERROR DECODE", err)

			newFn := RunTemplateGen(other, template.Types, usedFor).(*ast.FunctionDecl)

			newFn.Name += strings.Join(usedFor, "")

			topLevel := &ast.TopLevel{FunctionDecl: newFn}

			source.TopLevels = append(source.TopLevels, topLevel)

	*GenerateGenerics ->
		source := @root.(*ast.SourceFile)
		RunGobRegister(source)

		for _, template in @Templates.templates
			topArr := source.TopLevels
			for i, top in topArr
				if top.FunctionDecl == template.Node || (top.Declaration != nil && top.Declaration.TypeDecl != nil && top.Declaration.TypeDecl.StructType != nil && top.Declaration.TypeDecl.StructType == template.Node)
					if len(topArr) - 1 == i => source.TopLevels = source.TopLevels[:i]
					else if i == 0          => source.TopLevels = source.TopLevels[1:]
					else                    => source.TopLevels = append(source.TopLevels[0:i], source.TopLevels[i+1:]...)
					break

			switch template.Node.(type)
				*ast.FunctionDecl => @GenerateTopFns(template);
				*ast.StructType   => @GenerateStruct(template)

	*Arguments(n ast.INode): ast.INode ->
		args := n.(*ast.Arguments)

		if args.TemplateSpec != nil
			callee := args.GetParent().(*ast.SecondaryExpr).GetParent().(*ast.PrimaryExpr).PrimaryExpr.Operand

			calleeName := callee.Eval()

			types := []string{}

			for _, t in args.TemplateSpec.Result.Types
				types = append(types, t.Eval())

			template := @Templates.Get(calleeName)
			template.UsedFor = append(template.UsedFor, types)
			callee.OperandName.Name = calleeName + strings.Join(types, "")

		n

	*CompositeLit(n ast.INode): ast.INode ->
		composite := n.(*ast.CompositeLit)

		if composite.TemplateSpec != nil
			callee := composite.LiteralType

			calleeName := callee.Eval()

			types := []string{}

			for _, t in composite.TemplateSpec.Result.Types
				types = append(types, t.Eval())

			template := @Templates.Get(calleeName)
			template.UsedFor = append(template.UsedFor, types)
			callee.Type = calleeName + strings.Join(types, "")

		n

	*StructType(n ast.INode): ast.INode ->
		structType := n.(*ast.StructType)
		if structType.TemplateSpec != nil
			types := []string{}
			for _, t in structType.TemplateSpec.Result.Types
				types = append(types, t.Eval())

			@Templates.Add(structType.Name, &Template
				Name: structType.Name
				Types: types
				UsedFor: [][]string{}
				Node: structType
			)
		n

	*Signature(n ast.INode): ast.INode ->
		sig := n.(*ast.Signature)
		if sig.TemplateSpec != nil

			if f, ok := sig.GetParent().(*ast.Function); ok
				fDecl := f.GetParent().(*ast.FunctionDecl)

				types := []string{}
				for _, t in sig.TemplateSpec.Result.Types
					types = append(types, t.Eval())

				@Templates.Add(fDecl.Name, &Template
					Name: fDecl.Name
					Types: types
					UsedFor: [][]string{}
					Node: fDecl
				)
		n

	*VarDecl(n ast.INode): ast.INode ->
		varDecl := n.(*ast.VarDecl)
		for _, varSpec in varDecl.VarSpecs
			statement := varSpec.Statement
			if statement == nil
				continue

			ifStmt := statement.IfStmt
			if ifStmt == nil
				/* Hack: Get the inner ifStmt if existant */
				if statement.Block != nil && len(statement.Block.Statements) == 1 && statement.Block.Statements[0].IfStmt != nil
					ifStmt = statement.Block.Statements[0].IfStmt
				else
					continue

			varSpec.Statement = ifStmt.MakeReturnClosureStatement(varSpec.Type)

		varDecl

	*Function(n ast.INode): ast.INode ->
		function := n.(*ast.Function)
		sig := function.Signature

		/* No signature means no return type */
		if sig == nil
			return n

		retType := sig.Result

		/* We don't support multiple return type (yet) */
		if retType == nil || len(retType.Types) != 1
			return n

		block := function.Block
		if block != nil && len(block.Statements) > 0
			last := block.Statements[len(block.Statements)-1]

			if last.ReturnStmt == nil
				if last.SimpleStmt != nil => block.AddReturn()
				if last.IfStmt != nil     => last.IfStmt.AddReturn()

		n

// IfStmt::*MakeReturnClosureStatement(t *ast.Type): *Statement ->
// 	@AddReturn()

// 	/* FIXME: Problem with large nested struct decl */
// 	funcLit := &ast.FunctionLit
// 		Node: NewNodeNoCtx()
// 		Function: &ast.Function
// 			Node: NewNodeNoCtx()
// 			Signature: &ast.Signature
// 				Node: NewNodeNoCtx()
// 				Parameters: &ast.Parameters
// 					Node: NewNodeNoCtx()
// 					List: []*ast.Parameter{}
// 				Result: &ast.Result
// 					Node: NewNodeNoCtx()
// 					Types: []*ast.Type{t}
// 			Block: &ast.Block
// 				Node: NewNodeNoCtx()
// 				Statements: []*ast.Statement
// 					&ast.Statement
// 						Node: NewNodeNoCtx()
// 						IfStmt: @

// 	primary := &ast.PrimaryExpr
// 		Node: NewNodeNoCtx()
// 		Operand: &ast.Operand
// 			Node: NewNodeNoCtx()
// 			Literal: &ast.Literal
// 				Node: NewNodeNoCtx()
// 				FunctionLit: funcLit

// 	unary := &ast.UnaryExpr
// 		Node: NewNodeNoCtx()
// 		PrimaryExpr: &ast.PrimaryExpr
// 			Node: NewNodeNoCtx()
// 			PrimaryExpr: primary
// 			SecondaryExpr: &ast.SecondaryExpr
// 				Node: NewNodeNoCtx()
// 				Arguments: &ast.Arguments
// 					Node: NewNodeNoCtx()

// 	expr := &ast.Expression
// 		Node: NewNodeNoCtx()
// 		UnaryExpr: unary

// 	stmt := &ast.Statement
// 		Node: NewNodeNoCtx()
// 		SimpleStmt: &ast.SimpleStmt
// 			Node: NewNodeNoCtx()
// 			Expression: expr

// 	return stmt
// /* TODO: Fixme: without return the parser think this is `@AddReturn() & Statement` */
// /* return &Statement */
// // Node: NewNodeNoCtx()

// Block::*AddReturn() ->
// 	last := @Statements[len(@Statements)-1]

// 	if last.ReturnStmt == nil
// 		if last.IfStmt != nil
// 			last.IfStmt.AddReturn()
// 		if last.SimpleStmt != nil
// 			@Statements[len(@Statements)-1] = &Statement
// 				Node: NewNodeNoCtx()
// 				ReturnStmt: &ReturnStmt
// 					Node: NewNodeNoCtx()
// 					Expressions: &ExpressionList
// 						Node: NewNodeNoCtx()
// 						Expressions: []*Expression{last.SimpleStmt.Expression}

RunDesugar(tree ast.INode): ast.INode ->
	desugar := Desugar
		root:      tree

	desugar.type_ = &desugar

	res := desugar.Walk(tree)

	desugar.GenerateGenerics()

	res