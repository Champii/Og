!og

import
  fmt
  os
  path
  strings
  errors
  "os/exec"
  "io/ioutil"
  "path/filepath"

struct OgCompiler
  Config   *OgConfig
  Parser   *OgParser
  Preproc  *OgPreproc
  Printer  *Printer

  *Compile: error ->
    for _, p in @Config.Paths
      if err := filepath.Walk(p, @walker); err != nil
        fmt.Println("Error", err)

        return err

    if len(@Config.Files) == 0
      if @Config.Run
        return nil

    poolSize := @Config.Workers

    if len(@Config.Files) < poolSize
      poolSize = len(@Config.Files)

    pool := NewPool(poolSize, len(@Config.Files), @Printer, @readAndProceed)

    for _, file in @Config.Files
      pool.Queue(file)

    pool.Run()

  *walker(filePath string, info os.FileInfo, err error): error ->
    if err != nil
      return err

    if info.IsDir()
      return nil

    if path.Ext(filePath) != ".og"
      return nil

    if !@mustCompile(filePath, info)
      return nil

    @Config.Files = append(@Config.Files, filePath)

    nil

  mustCompile(filePath string, info os.FileInfo): bool ->
    newPath := @getNewPath(filePath)

    stat, err := os.Stat(newPath)
    if err != nil
      return true

    if @Config.Print || @Config.Ast || @Config.Dirty || @Config.Blocks
      return true

    return info.ModTime().After(stat.ModTime())

  *readAndProceed(filePath string): error ->
    source, err := ioutil.ReadFile(filePath)

    if err != nil
      return err

    res, err := @ProcessFile(filePath, string(source))

    if err != nil
      return err

    @finalizeFile(filePath, res)

    return nil

  ProcessFile(filePath string, data string): string, error ->
    preprocessed := @Preproc.Run(string(data))

    if @Config.Blocks
      return preprocessed, nil

    res := ""
    if !@Config.Interpreter
      res = @Parser.Parse(@Config, filePath, string(preprocessed))
    else
      res = @Parser.ParseInterpret(filePath, string(preprocessed))

    if @Config.Dirty
      return res, nil

    return @format(res)

  getNewPath(filePath string): string ->
    if @Config.OutPath != "./"
      splited := strings.SplitN(filePath, "/", 2)
      filePath = splited[1]

    strings.Replace(path.Join(@Config.OutPath, filePath), ".og", ".go", 1)

  finalizeFile(filePath string, data string) ->
    if @Config.Print || @Config.Dirty || @Config.Blocks
      fmt.Println(data)
    else
      @writeFile(filePath, data)

  writeFile(filePath string, data string) ->
    newPath := @getNewPath(filePath)

    os.MkdirAll(filepath.Dir(newPath), os.ModePerm);

    ioutil.WriteFile(newPath, []byte(data), os.ModePerm)

  format(str string): string, error ->
    cmd := exec.Command("gofmt")

    stdin, _ := cmd.StdinPipe()

    stdin.Write([]byte(str))
    stdin.Close()

    final, err := cmd.CombinedOutput()

    if err != nil
      fmt.Println("!!! THIS IS A BUG !!!\n")
      fmt.Println("If you see this text, Oglang have generated an invalid Go code")
      fmt.Println("and cannot go through the go formater.")
      fmt.Println("You should report this as an issue along with the file that produced that error")
      fmt.Println("https://github.com/Champii/og/issues")
      return "", errors.New(string(final))

    return string(final), nil

NewOgCompiler(config *OgConfig, printer *Printer): *OgCompiler ->
  &OgCompiler
    Config: config
    Printer: printer
    Parser: NewOgParser(config)
    Preproc: NewOgPreproc()
