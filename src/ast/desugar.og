!ast

// import
// 	fmt
// 	reflect

var mangle = 0

struct Desugar
	AstWalker

	*VarDecl(n INode): INode ->
		varDecl := n.(*VarDecl)
		for _, varSpec in varDecl.VarSpecs
			statement := varSpec.Statement
			if statement == nil
				continue

			ifStmt := statement.IfStmt
			if ifStmt == nil
				// Hack: Get the inner ifStmt if existant
				if statement.Block != nil && len(statement.Block.Statements) == 1 && statement.Block.Statements[0].IfStmt != nil
					ifStmt = statement.Block.Statements[0].IfStmt
				else
					continue

			varSpec.Statement = ifStmt.MakeReturnClosureStatement(varSpec.Type)

		varDecl

	*Function(n INode): INode ->
		function := n.(*Function)
		sig := function.Signature

		// No signature means no return type
		if sig == nil
			return n

		retType := sig.Result

		// We don't support multiple return type (yet)
		if retType == nil || len(retType.Types) != 1
			return n

		block := function.Block
		if block != nil && len(block.Statements) > 0
			last := block.Statements[len(block.Statements)-1]

			if last.ReturnStmt == nil
				if last.SimpleStmt != nil => block.AddReturn()
				if last.IfStmt != nil     => last.IfStmt.AddReturn()

		n

IfStmt::*MakeReturnClosureStatement(t *Type): *Statement ->
	@AddReturn()

	// FIXME: Problem with large nested struct decl
	funcLit := &FunctionLit
		Node: NewNodeNoCtx()
		Function: &Function
			Node: NewNodeNoCtx()
			Signature: &Signature
				Node: NewNodeNoCtx()
				Parameters: &Parameters
					Node: NewNodeNoCtx()
					List: []*Parameter{}
				Result: &Result
					Node: NewNodeNoCtx()
					Types: []*Type{t}
			Block: &Block
				Node: NewNodeNoCtx()
				Statements: []*Statement
					&Statement
						Node: NewNodeNoCtx()
						IfStmt: @

	primary := &PrimaryExpr
		Node: NewNodeNoCtx()
		Operand: &Operand
			Node: NewNodeNoCtx()
			Literal: &Literal
				Node: NewNodeNoCtx()
				FunctionLit: funcLit

	unary := &UnaryExpr
		Node: NewNodeNoCtx()
		PrimaryExpr: &PrimaryExpr
			Node: NewNodeNoCtx()
			PrimaryExpr: primary
			SecondaryExpr: &SecondaryExpr
				Node: NewNodeNoCtx()
				Arguments: &Arguments
					Node: NewNodeNoCtx()

	expr := &Expression
		Node: NewNodeNoCtx()
		UnaryExpr: unary

	stmt := &Statement
		Node: NewNodeNoCtx()
		SimpleStmt: &SimpleStmt
			Node: NewNodeNoCtx()
			Expression: expr

	return stmt
	// TODO: Fixme: without return the parser think this is `@AddReturn() & Statement`
	// return &Statement
	// 	Node: NewNodeNoCtx()

IfStmt::*AddReturn() ->
	if @Block     != nil => @Block.AddReturn()
	if @IfStmt    != nil => @IfStmt.AddReturn()
	if @BlockElse != nil => @BlockElse.AddReturn()

Block::*AddReturn() ->
	last := @Statements[len(@Statements)-1]

	if last.ReturnStmt == nil
		if last.IfStmt != nil
			last.IfStmt.AddReturn()
		if last.SimpleStmt != nil
			@Statements[len(@Statements)-1] = &Statement
				Node: NewNodeNoCtx()
				ReturnStmt: &ReturnStmt
					Node: NewNodeNoCtx()
					Expressions: &ExpressionList
						Node: NewNodeNoCtx()
						Expressions: []*Expression{last.SimpleStmt.Expression}

RunDesugar(ast INode): INode ->
	desugar := Desugar{}

	desugar.type_ = &desugar

	desugar.Walk(ast)
