!og

import
  fmt
  path
  strings
  os
  "path/filepath"
  "io/ioutil"
  "os/exec"

struct OgConfig
  Blocks  bool
  Dirty   bool
  Print   bool
  Verbose bool
  Paths   []string
  OutPath string


var config OgConfig

Compile(config_ OgConfig): error ->
  config = config_

  for _, p in config.Paths
    if err := filepath.Walk(p, walker); err != nil
      fmt.Println("Error", err)

      return err

  return nil

walker(filePath string, info os.FileInfo, err error): error ->
  if err != nil
    return err

  if info.IsDir() == true
    return nil

  if path.Ext(filePath) != ".og"
    return nil

  source, err := ioutil.ReadFile(filePath)

  if err != nil
    return err

  res, err := ProcessFile(filePath, string(source))

  if err != nil
    return err

  finalizeFile(filePath, res)

  return nil

ProcessFile(filePath string, data string): string, error ->
  if config.Verbose == true
    fmt.Print(filePath)

  preprocessed := Preproc(string(data))

  if config.Blocks == true
    return preprocessed, nil

  res := Parse(filePath, string(preprocessed))

  if config.Dirty == true
    return res, nil

  return format(res)

finalizeFile(filePath string, data string) ->
  if config.Print == true
    fmt.Println(data)
  else
    writeFile(filePath, data)

writeFile(filePath string, data string) ->
  if config.OutPath != "./"
    splited := strings.SplitN(filePath, "/", 2)
    filePath = splited[1]

  newPath := strings.Replace(path.Join(config.OutPath, filePath), ".og", ".go", 1)

  os.MkdirAll(filepath.Dir(newPath), os.ModePerm);

  ioutil.WriteFile(newPath, []byte(data), os.ModePerm)

  if config.Verbose == true
    fmt.Println("->", newPath)


format(str string): string, error ->
  cmd := exec.Command("gofmt")

  stdin, _ := cmd.StdinPipe()

  stdin.Write([]byte(str))
  stdin.Close()

  final, err := cmd.CombinedOutput()

  if err != nil
    return "", err

  return string(final), nil
