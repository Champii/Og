!translator

import
  strings
  "github.com/champii/og/lib/ast": .
  "github.com/champii/og/parser"
  "github.com/antlr/antlr4/runtime/Go/antlr"

// type Scope map[string]string

// struct Stack
//   scopes []Scope
//   *newScope                -> @scopes = append([]Scope{Scope{}}, @scopes...)
//   *popScope                -> @scopes = @scopes[1:]
//   *add(v string, t string) -> @scopes[0][v] = t

struct OgVisitor
  *antlr.BaseParseTreeVisitor

  Aggregate(resultSoFar interface, childResult interface): interface ->
    switch childResult.(type)
      _      => return resultSoFar
      string =>
        switch resultSoFar.(type)
          string => return resultSoFar.(string) + childResult.(string)
          _      => return childResult

    return nil

  // *parser.SourceFileContext -> antlr.ParseTreeVisitor -> interface
  // VisitSourceFile(ctx, delegate) -> @VisitChildren(ctx, delegate)

  VisitSourceFile(ctx *parser.SourceFileContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &SourceFile
      Node:          NewNode(ctx)
      Package: @VisitPackageClause(ctx.PackageClause().(*parser.PackageClauseContext), delegate).(*Package)

    if ctx.ImportDecl(0) != nil
      node.Import = @VisitImportDecl(ctx.ImportDecl(0).(*parser.ImportDeclContext), delegate).(*Import)

    res := []*TopLevel{}

    bodies := ctx.AllTopLevelDecl()

    for _, spec in bodies
      res = append(res, @VisitTopLevelDecl(spec.(*parser.TopLevelDeclContext), delegate).(*TopLevel))

    node.TopLevels = res

    return node

  VisitPackageClause(ctx *parser.PackageClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Package
      Node: NewNode(ctx)
      Name: ctx.IDENTIFIER().GetText()

  VisitImportDecl(ctx *parser.ImportDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Import
      Node:    NewNode(ctx)
      Items:   @VisitImportBody(ctx.ImportBody().(*parser.ImportBodyContext), delegate).([]*ImportSpec)

  VisitImportBody(ctx *parser.ImportBodyContext, delegate antlr.ParseTreeVisitor): interface ->
    res := []*ImportSpec{}

    bodies := ctx.AllImportSpec()

    for _, spec in bodies
      res = append(res, @VisitImportSpec(spec.(*parser.ImportSpecContext), delegate).(*ImportSpec))

    return res

  VisitImportSpec(ctx *parser.ImportSpecContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ImportSpec
      Node: NewNode(ctx)

    if ctx.ImportPath() != nil
      node.Path = @VisitImportPath(ctx.ImportPath().(*parser.ImportPathContext), delegate).(string)

    if ctx.IDENTIFIER() != nil
      node.Alias = ctx.IDENTIFIER().GetText()
    else if strings.Contains(ctx.GetText(), ":")
      node.Alias = "."

    return node

  VisitImportPath(ctx *parser.ImportPathContext, delegate antlr.ParseTreeVisitor): interface ->
    txt := ctx.GetText()

    if txt[0] == '"'
      return txt + "\n"
    else
      return "\"" + txt + "\"\n"

  VisitTopLevelDecl(ctx *parser.TopLevelDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TopLevel
      Node: NewNode(ctx)

    if ctx.Declaration() != nil
      node.Declaration = @VisitDeclaration(ctx.Declaration().(*parser.DeclarationContext), delegate).(*Declaration)

    if ctx.FunctionDecl() != nil
      node.FunctionDecl = @VisitFunctionDecl(ctx.FunctionDecl().(*parser.FunctionDeclContext), delegate).(*FunctionDecl)

    if ctx.MethodDecl() != nil
      node.MethodDecl = @VisitMethodDecl(ctx.MethodDecl().(*parser.MethodDeclContext), delegate).(*MethodDecl)

    return node

  VisitDeclaration(ctx *parser.DeclarationContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Declaration
      Node: NewNode(ctx)

    if ctx.ConstDecl() != nil
      node.ConstDecl = @VisitConstDecl(ctx.ConstDecl().(*parser.ConstDeclContext), delegate).(*ConstDecl)

    if ctx.TypeDecl() != nil
      node.TypeDecl = @VisitTypeDecl(ctx.TypeDecl().(*parser.TypeDeclContext), delegate).(*TypeDecl)

    if ctx.VarDecl() != nil
      node.VarDecl = @VisitVarDecl(ctx.VarDecl().(*parser.VarDeclContext), delegate).(*VarDecl)

    return node

  VisitConstDecl(ctx *parser.ConstDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ConstDecl
      Node: NewNode(ctx)

    res := []*ConstSpec{}

    bodies := ctx.AllConstSpec()

    for _, spec in bodies
      res = append(res, @VisitConstSpec(spec.(*parser.ConstSpecContext), delegate).(*ConstSpec))

    node.ConstSpecs = res

    return node

  VisitConstSpec(ctx *parser.ConstSpecContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ConstSpec
      Node: NewNode(ctx)

    if ctx.IdentifierList() != nil
      node.IdentifierList = @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    if ctx.Type_() != nil
      node.Type = @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

    if ctx.ExpressionList() != nil
      node.ExpressionList = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    return node

  VisitIdentifierList(ctx *parser.IdentifierListContext, delegate antlr.ParseTreeVisitor): interface ->
    return strings.Split(ctx.GetText(), ",")

  VisitExpressionList(ctx *parser.ExpressionListContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ExpressionList
      Node: NewNode(ctx)

    res := []*Expression{}

    bodies := ctx.AllExpression()

    for _, spec in bodies
      res = append(res, @VisitExpression(spec.(*parser.ExpressionContext), delegate).(*Expression))

    node.Expressions = res

    return node

  VisitTypeDecl(ctx *parser.TypeDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TypeDecl
      Node: NewNode(ctx)

    if len(ctx.AllTypeSpec()) > 0
      res := []*TypeSpec{}

      bodies := ctx.AllTypeSpec()

      for _, spec in bodies
        res = append(res, @VisitTypeSpec(spec.(*parser.TypeSpecContext), delegate).(*TypeSpec))

      node.TypeSpecs = res

    if ctx.StructType() != nil
      node.StructType = @VisitStructType(ctx.StructType().(*parser.StructTypeContext), delegate).(*StructType)

    if ctx.InterfaceType() != nil
      node.InterfaceType = @VisitInterfaceType(ctx.InterfaceType().(*parser.InterfaceTypeContext), delegate).(*InterfaceType)

    return node

  VisitTypeSpec(ctx *parser.TypeSpecContext, delegate antlr.ParseTreeVisitor): interface ->
    return &TypeSpec
      Node: NewNode(ctx)
      Name: ctx.IDENTIFIER().GetText()
      Type: @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

  VisitFunctionDecl(ctx *parser.FunctionDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &FunctionDecl
      Node: NewNode(ctx)
      Name: ctx.IDENTIFIER().GetText()

    if ctx.Function() != nil
      node.Function = @VisitFunction(ctx.Function().(*parser.FunctionContext), delegate).(*Function)

    if ctx.Signature() != nil
      node.Signature = @VisitSignature(ctx.Signature().(*parser.SignatureContext), delegate).(*Signature)

    return node

  VisitFunction(ctx *parser.FunctionContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Function
      Node: NewNode(ctx)
      Signature: @VisitSignature(ctx.Signature().(*parser.SignatureContext), delegate).(*Signature)

    if ctx.Block() != nil
      node.Block = @VisitBlock(ctx.Block().(*parser.BlockContext), delegate).(*Block)

    if ctx.StatementNoBlock() != nil
      node.Block = @VisitStatementNoBlock(ctx.StatementNoBlock().(*parser.StatementNoBlockContext), delegate).(*Block)

    return node

  VisitMethodDecl(ctx *parser.MethodDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &MethodDecl
      Node: NewNode(ctx)
      Receiver: @VisitReceiver(ctx.Receiver().(*parser.ReceiverContext), delegate).(*Receiver)

    if ctx.Function() != nil
      node.Function = @VisitFunction(ctx.Function().(*parser.FunctionContext), delegate).(*Function)

    if ctx.Signature() != nil
      node.Signature = @VisitSignature(ctx.Signature().(*parser.SignatureContext), delegate).(*Signature)

    return node

  VisitReceiver(ctx *parser.ReceiverContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Receiver
      Node: NewNode(ctx)
      Package: ctx.IDENTIFIER(0).GetText()
      IsPointerReceiver: strings.Contains(ctx.GetText(), "*")
      Method: ctx.IDENTIFIER(1).GetText()

  VisitVarDecl(ctx *parser.VarDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &VarDecl
      Node: NewNode(ctx)

    res := []*VarSpec{}

    bodies := ctx.AllVarSpec()

    for _, spec in bodies
      res = append(res, @VisitVarSpec(spec.(*parser.VarSpecContext), delegate).(*VarSpec))

    node.VarSpecs = res

    return node

  VisitVarSpec(ctx *parser.VarSpecContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &VarSpec
      Node: NewNode(ctx)
      IdentifierList: @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    if ctx.Type_() != nil
      node.Type = @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

    if ctx.ExpressionList() != nil
      node.ExpressionList = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    return node

  VisitBlock(ctx *parser.BlockContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Block
      Node: NewNode(ctx)
      Statements: @VisitStatementList(ctx.StatementList().(*parser.StatementListContext), delegate).([]*Statement)

  VisitStatementList(ctx *parser.StatementListContext, delegate antlr.ParseTreeVisitor): interface ->
    res := []*Statement{}

    bodies := ctx.AllStatement()

    for _, spec in bodies
      res = append(res, @VisitStatement(spec.(*parser.StatementContext), delegate).(*Statement))

    return res

  VisitStatement(ctx *parser.StatementContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Statement
      Node: NewNode(ctx)

    if ctx.SimpleStmt() != nil
      node.SimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt().(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    if ctx.LabeledStmt() != nil
      node.LabeledStmt = @VisitLabeledStmt(ctx.LabeledStmt().(*parser.LabeledStmtContext), delegate).(*LabeledStmt)

    if ctx.GoStmt() != nil
      node.GoStmt = @VisitGoStmt(ctx.GoStmt().(*parser.GoStmtContext), delegate).(*GoStmt)

    if ctx.ReturnStmt() != nil
      node.ReturnStmt = @VisitReturnStmt(ctx.ReturnStmt().(*parser.ReturnStmtContext), delegate).(*ReturnStmt)

    if ctx.BreakStmt() != nil
      node.BreakStmt = @VisitBreakStmt(ctx.BreakStmt().(*parser.BreakStmtContext), delegate).(*BreakStmt)

    if ctx.ContinueStmt() != nil
      node.ContinueStmt = @VisitContinueStmt(ctx.ContinueStmt().(*parser.ContinueStmtContext), delegate).(*ContinueStmt)

    if ctx.GotoStmt() != nil
      node.GotoStmt = @VisitGotoStmt(ctx.GotoStmt().(*parser.GotoStmtContext), delegate).(*GotoStmt)

    if ctx.FallthroughStmt() != nil
      node.FallthroughStmt = @VisitFallthroughStmt(ctx.FallthroughStmt().(*parser.FallthroughStmtContext), delegate).(*FallthroughStmt)

    if ctx.IfStmt() != nil
      node.IfStmt = @VisitIfStmt(ctx.IfStmt().(*parser.IfStmtContext), delegate).(*IfStmt)

    if ctx.SwitchStmt() != nil
      node.SwitchStmt = @VisitSwitchStmt(ctx.SwitchStmt().(*parser.SwitchStmtContext), delegate).(*SwitchStmt)

    if ctx.SelectStmt() != nil
      node.SelectStmt = @VisitSelectStmt(ctx.SelectStmt().(*parser.SelectStmtContext), delegate).(*SelectStmt)

    if ctx.ForStmt() != nil
      node.ForStmt = @VisitForStmt(ctx.ForStmt().(*parser.ForStmtContext), delegate).(*ForStmt)

    if ctx.Block() != nil
      node.Block = @VisitBlock(ctx.Block().(*parser.BlockContext), delegate).(*Block)

    if ctx.DeferStmt() != nil
      node.DeferStmt = @VisitDeferStmt(ctx.DeferStmt().(*parser.DeferStmtContext), delegate).(*DeferStmt)

    return node

  VisitStatementNoBlock(ctx *parser.StatementNoBlockContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Block
      Node: NewNode(ctx)

    res := &Statement{}

    if ctx.SimpleStmt() != nil
      res.SimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt().(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    if ctx.LabeledStmt() != nil
      res.LabeledStmt = @VisitLabeledStmt(ctx.LabeledStmt().(*parser.LabeledStmtContext), delegate).(*LabeledStmt)

    if ctx.GoStmt() != nil
      res.GoStmt = @VisitGoStmt(ctx.GoStmt().(*parser.GoStmtContext), delegate).(*GoStmt)

    if ctx.ReturnStmt() != nil
      res.ReturnStmt = @VisitReturnStmt(ctx.ReturnStmt().(*parser.ReturnStmtContext), delegate).(*ReturnStmt)

    if ctx.BreakStmt() != nil
      res.BreakStmt = @VisitBreakStmt(ctx.BreakStmt().(*parser.BreakStmtContext), delegate).(*BreakStmt)

    if ctx.ContinueStmt() != nil
      res.ContinueStmt = @VisitContinueStmt(ctx.ContinueStmt().(*parser.ContinueStmtContext), delegate).(*ContinueStmt)

    if ctx.GotoStmt() != nil
      res.GotoStmt = @VisitGotoStmt(ctx.GotoStmt().(*parser.GotoStmtContext), delegate).(*GotoStmt)

    if ctx.FallthroughStmt() != nil
      res.FallthroughStmt = @VisitFallthroughStmt(ctx.FallthroughStmt().(*parser.FallthroughStmtContext), delegate).(*FallthroughStmt)

    if ctx.IfStmt() != nil
      res.IfStmt = @VisitIfStmt(ctx.IfStmt().(*parser.IfStmtContext), delegate).(*IfStmt)

    if ctx.SwitchStmt() != nil
      res.SwitchStmt = @VisitSwitchStmt(ctx.SwitchStmt().(*parser.SwitchStmtContext), delegate).(*SwitchStmt)

    if ctx.SelectStmt() != nil
      res.SelectStmt = @VisitSelectStmt(ctx.SelectStmt().(*parser.SelectStmtContext), delegate).(*SelectStmt)

    if ctx.ForStmt() != nil
      res.ForStmt = @VisitForStmt(ctx.ForStmt().(*parser.ForStmtContext), delegate).(*ForStmt)

    if ctx.DeferStmt() != nil
      res.DeferStmt = @VisitDeferStmt(ctx.DeferStmt().(*parser.DeferStmtContext), delegate).(*DeferStmt)

    node.Statements = []*Statement{res}

    return node

  VisitSimpleStmt(ctx *parser.SimpleStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &SimpleStmt
      Node: NewNode(ctx)

    if ctx.SendStmt() != nil
      node.SendStmt = @VisitSendStmt(ctx.SendStmt().(*parser.SendStmtContext), delegate).(*SendStmt)

    if ctx.ExpressionStmt() != nil
      node.Expression = @VisitExpressionStmt(ctx.ExpressionStmt().(*parser.ExpressionStmtContext), delegate).(*Expression)

    if ctx.IncDecStmt() != nil
      node.IncDecStmt = @VisitIncDecStmt(ctx.IncDecStmt().(*parser.IncDecStmtContext), delegate).(*IncDecStmt)

    if ctx.ShortVarDecl() != nil
      node.ShortVarDecl = @VisitShortVarDecl(ctx.ShortVarDecl().(*parser.ShortVarDeclContext), delegate).(*ShortVarDecl)

    if ctx.Assignment() != nil
      node.Assignment = @VisitAssignment(ctx.Assignment().(*parser.AssignmentContext), delegate).(*Assignment)

    if ctx.EmptyStmt() != nil
      node.EmptyStmt = true

    return node

  VisitExpressionStmt(ctx *parser.ExpressionStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

  VisitSendStmt(ctx *parser.SendStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &SendStmt
      Node: NewNode(ctx)
      Left: @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)
      Right: @VisitExpression(ctx.Expression(1).(*parser.ExpressionContext), delegate).(*Expression)

  VisitIncDecStmt(ctx *parser.IncDecStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &IncDecStmt
      Node: NewNode(ctx)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)
      IsInc: strings.Contains(ctx.GetText(), "++")

  VisitAssignment(ctx *parser.AssignmentContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Assignment
      Node: NewNode(ctx)
      Left: @VisitExpressionList(ctx.ExpressionList(0).(*parser.ExpressionListContext), delegate).(*ExpressionList)
      Op: @VisitAssign_op(ctx.Assign_op().(*parser.Assign_opContext), delegate).(string)
      Right: @VisitExpressionList(ctx.ExpressionList(1).(*parser.ExpressionListContext), delegate).(*ExpressionList)

  VisitAssign_op(ctx *parser.Assign_opContext, delegate antlr.ParseTreeVisitor): interface ->
    if len(ctx.GetText()) == 1
      return "="

    return ctx.GetText()

  VisitBinary_op(ctx *parser.Binary_opContext, delegate antlr.ParseTreeVisitor): interface ->
    return ctx.GetText()

  VisitShortVarDecl(ctx *parser.ShortVarDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ShortVarDecl
      Node: NewNode(ctx)
      Identifiers: @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)
    else if ctx.StatementNoBlock() != nil
      node.Statement = @VisitStatementNoBlock(ctx.StatementNoBlock().(*parser.StatementNoBlockContext), delegate).(*Block).Statements[0]

    return node

  VisitEmptyStmt(ctx *parser.EmptyStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return "\n"

  VisitLabeledStmt(ctx *parser.LabeledStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &LabeledStmt
      Node: NewNode(ctx)
      Name: ctx.IDENTIFIER().GetText()
      Statement: @VisitStatement(ctx.Statement().(*parser.StatementContext), delegate).(*Statement)

  VisitReturnStmt(ctx *parser.ReturnStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ReturnStmt
      Node: NewNode(ctx)

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    return node

  VisitBreakStmt(ctx *parser.BreakStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &BreakStmt
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    return node

  VisitContinueStmt(ctx *parser.ContinueStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node :=  &ContinueStmt
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    return node

  VisitGotoStmt(ctx *parser.GotoStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &GotoStmt
      Node: NewNode(ctx)
      Name: ctx.IDENTIFIER().GetText()

  VisitFallthroughStmt(ctx *parser.FallthroughStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &FallthroughStmt
      Node: NewNode(ctx)

  VisitDeferStmt(ctx *parser.DeferStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    return &DeferStmt
      Node: NewNode(ctx)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

  VisitIfStmt(ctx *parser.IfStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &IfStmt
      Node: NewNode(ctx)

    if ctx.SimpleStmt() != nil
      node.SimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt().(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.Block(0) != nil
      node.Block = @VisitBlock(ctx.Block(0).(*parser.BlockContext), delegate).(*Block)
    else if ctx.StatementNoBlock(0) != nil
      node.Block = @VisitStatementNoBlock(ctx.StatementNoBlock(0).(*parser.StatementNoBlockContext), delegate).(*Block)

    if ctx.Block(1) != nil
      node.BlockElse = @VisitBlock(ctx.Block(1).(*parser.BlockContext), delegate).(*Block)
    else if ctx.StatementNoBlock(1) != nil
      node.BlockElse = @VisitStatementNoBlock(ctx.StatementNoBlock(1).(*parser.StatementNoBlockContext), delegate).(*Block)
    else if ctx.IfStmt() != nil
      node.IfStmt = @VisitIfStmt(ctx.IfStmt().(*parser.IfStmtContext), delegate).(*IfStmt)

    return node

  VisitSwitchStmt(ctx *parser.SwitchStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &SwitchStmt
      Node: NewNode(ctx)

    if ctx.ExprSwitchStmt() != nil
      node.ExprSwitchStmt = @VisitExprSwitchStmt(ctx.ExprSwitchStmt().(*parser.ExprSwitchStmtContext), delegate).(*ExprSwitchStmt)

    if ctx.TypeSwitchStmt() != nil
      node.TypeSwitchStmt = @VisitTypeSwitchStmt(ctx.TypeSwitchStmt().(*parser.TypeSwitchStmtContext), delegate).(*TypeSwitchStmt)

    return node

  VisitExprSwitchStmt(ctx *parser.ExprSwitchStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ExprSwitchStmt
      Node: NewNode(ctx)

    if ctx.SimpleStmt() != nil
      node.SimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt().(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    res := []*ExprCaseClause{}

    bodies := ctx.AllExprCaseClause()

    for _, spec in bodies
      res = append(res, @VisitExprCaseClause(spec.(*parser.ExprCaseClauseContext), delegate).(*ExprCaseClause))

    node.ExprCaseClauses = res

    return node

  VisitExprCaseClause(ctx *parser.ExprCaseClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    return &ExprCaseClause
      Node: NewNode(ctx)
      ExprSwitchCase: @VisitExprSwitchCase(ctx.ExprSwitchCase().(*parser.ExprSwitchCaseContext), delegate).(*ExprSwitchCase)
      Statements: @VisitStatementList(ctx.StatementList().(*parser.StatementListContext), delegate).([]*Statement)

  VisitExprSwitchCase(ctx *parser.ExprSwitchCaseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ExprSwitchCase
      Node: NewNode(ctx)

    if ctx.GetText() == "_"
      node.IsDefault = true
      return node

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    return node

  VisitTypeSwitchStmt(ctx *parser.TypeSwitchStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TypeSwitchStmt
      Node: NewNode(ctx)
      TypeSwitchGuard: @VisitTypeSwitchGuard(ctx.TypeSwitchGuard().(*parser.TypeSwitchGuardContext), delegate).(*TypeSwitchGuard)

    if ctx.SimpleStmt() != nil
      node.SimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt().(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    res := []*TypeCaseClause{}

    bodies := ctx.AllTypeCaseClause()

    for _, spec in bodies
      res = append(res, @VisitTypeCaseClause(spec.(*parser.TypeCaseClauseContext), delegate).(*TypeCaseClause))

    node.TypeCaseClauses = res

    return node

  VisitTypeSwitchGuard(ctx *parser.TypeSwitchGuardContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TypeSwitchGuard
      Node: NewNode(ctx)
      PrimaryExpr: @VisitPrimaryExpr(ctx.PrimaryExpr().(*parser.PrimaryExprContext), delegate).(*PrimaryExpr)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    return node

  VisitTypeCaseClause(ctx *parser.TypeCaseClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    return &TypeCaseClause
      Node: NewNode(ctx)
      TypeSwitchCase: @VisitTypeSwitchCase(ctx.TypeSwitchCase().(*parser.TypeSwitchCaseContext), delegate).(*TypeSwitchCase)
      Statements: @VisitStatementList(ctx.StatementList().(*parser.StatementListContext), delegate).([]*Statement)

  VisitTypeSwitchCase(ctx *parser.TypeSwitchCaseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TypeSwitchCase
      Node: NewNode(ctx)

    if ctx.TypeList() != nil
      node.Types = @VisitTypeList(ctx.TypeList().(*parser.TypeListContext), delegate).([]*Type)

    return node

  VisitTypeList(ctx *parser.TypeListContext, delegate antlr.ParseTreeVisitor): interface ->
    res := []*Type{}

    bodies := ctx.AllType_()

    for _, spec in bodies
      res = append(res, @VisitType_(spec.(*parser.Type_Context), delegate).(*Type))

    return res

  VisitSelectStmt(ctx *parser.SelectStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &SelectStmt
      Node: NewNode(ctx)

    res := []*CommClause{}

    bodies := ctx.AllCommClause()

    for _, spec in bodies
      res = append(res, @VisitCommClause(spec.(*parser.CommClauseContext), delegate).(*CommClause))

    node.CommClauses = res

    return node

  VisitCommClause(ctx *parser.CommClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &CommClause
      Node: NewNode(ctx)
      CommCase: @VisitCommCase(ctx.CommCase().(*parser.CommCaseContext), delegate).(*CommCase)

    if ctx.Block() != nil
      node.Block = @VisitBlock(ctx.Block().(*parser.BlockContext), delegate).(*Block)
    else if ctx.StatementNoBlock() != nil
      node.Block = @VisitStatementNoBlock(ctx.StatementNoBlock().(*parser.StatementNoBlockContext), delegate).(*Block)

    return node

  VisitCommCase(ctx *parser.CommCaseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &CommCase
      Node: NewNode(ctx)

    if ctx.GetText() == "_"
      node.IsDefault = true
      return node

    if ctx.SendStmt() != nil
      node.SendStmt = @VisitSendStmt(ctx.SendStmt().(*parser.SendStmtContext), delegate).(*SendStmt)

    if ctx.RecvStmt() != nil
      node.RecvStmt = @VisitRecvStmt(ctx.RecvStmt().(*parser.RecvStmtContext), delegate).(*RecvStmt)

    return node

  VisitRecvStmt(ctx *parser.RecvStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &RecvStmt
      Node: NewNode(ctx)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    if ctx.IdentifierList() != nil
      node.Identifiers = @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    return node

  VisitForStmt(ctx *parser.ForStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ForStmt
      Node: NewNode(ctx)
      Block: @VisitBlock(ctx.Block().(*parser.BlockContext), delegate).(*Block)

    if ctx.ForClause() != nil
      node.ForClause = @VisitForClause(ctx.ForClause().(*parser.ForClauseContext), delegate).(*ForClause)

    if ctx.RangeClause() != nil
      node.RangeClause = @VisitRangeClause(ctx.RangeClause().(*parser.RangeClauseContext), delegate).(*RangeClause)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    return node

  VisitForClause(ctx *parser.ForClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ForClause
      Node: NewNode(ctx)

    if ctx.SimpleStmt(0) != nil
      node.LeftSimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt(0).(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.SimpleStmt(1) != nil
      node.RightSimpleStmt = @VisitSimpleStmt(ctx.SimpleStmt(1).(*parser.SimpleStmtContext), delegate).(*SimpleStmt)

    return node

  VisitRangeClause(ctx *parser.RangeClauseContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &RangeClause
      Node: NewNode(ctx)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    if ctx.IdentifierList() != nil
      node.Identifiers = @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    return node

  VisitGoStmt(ctx *parser.GoStmtContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &GoStmt
      Node: NewNode(ctx)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.Function() != nil
      node.Function = @VisitFunction(ctx.Function().(*parser.FunctionContext), delegate).(*Function)

    return node

  VisitType_(ctx *parser.Type_Context, delegate antlr.ParseTreeVisitor): interface ->
    node := &Type
      Node: NewNode(ctx)

    if ctx.TypeName() != nil
      node.TypeName = @VisitTypeName(ctx.TypeName().(*parser.TypeNameContext), delegate).(string)

    if ctx.TypeLit() != nil
      node.TypeLit = @VisitTypeLit(ctx.TypeLit().(*parser.TypeLitContext), delegate).(*TypeLit)

    if ctx.Type_() != nil
      node.Type = @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

    return node

  VisitTypeName(ctx *parser.TypeNameContext, delegate antlr.ParseTreeVisitor): interface ->
    return ctx.GetText()

  VisitTypeLit(ctx *parser.TypeLitContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &TypeLit
      Node: NewNode(ctx)

    if ctx.ArrayType() != nil
      node.ArrayType = @VisitArrayType(ctx.ArrayType().(*parser.ArrayTypeContext), delegate).(*ArrayType)

    if ctx.StructType() != nil
      node.StructType = @VisitStructType(ctx.StructType().(*parser.StructTypeContext), delegate).(*StructType)

    if ctx.PointerType() != nil
      node.PointerType = @VisitPointerType(ctx.PointerType().(*parser.PointerTypeContext), delegate).(*PointerType)

    if ctx.FunctionType() != nil
      node.FunctionType = @VisitFunctionType(ctx.FunctionType().(*parser.FunctionTypeContext), delegate).(*FunctionType)

    if ctx.InterfaceType() != nil
      node.InterfaceType = @VisitInterfaceType(ctx.InterfaceType().(*parser.InterfaceTypeContext), delegate).(*InterfaceType)

    if ctx.SliceType() != nil
      node.SliceType = @VisitSliceType(ctx.SliceType().(*parser.SliceTypeContext), delegate).(*SliceType)

    if ctx.MapType() != nil
      node.MapType = @VisitMapType(ctx.MapType().(*parser.MapTypeContext), delegate).(*MapType)

    if ctx.ChannelType() != nil
      node.ChannelType = @VisitChannelType(ctx.ChannelType().(*parser.ChannelTypeContext), delegate).(*ChannelType)

    return node

  VisitArrayType(ctx *parser.ArrayTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &ArrayType
      Node: NewNode(ctx)
      Length:  @VisitArrayLength(ctx.ArrayLength().(*parser.ArrayLengthContext), delegate).(*Expression)
      ElementType:  @VisitElementType(ctx.ElementType().(*parser.ElementTypeContext), delegate).(*Type)

  VisitArrayLength(ctx *parser.ArrayLengthContext, delegate antlr.ParseTreeVisitor): interface ->
    return @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

  VisitElementType(ctx *parser.ElementTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

  VisitPointerType(ctx *parser.PointerTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &PointerType
      Node: NewNode(ctx)
      Type:  @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

  VisitInterfaceType(ctx *parser.InterfaceTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &InterfaceType
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    res := []*MethodSpec{}

    bodies := ctx.AllMethodSpec()

    for _, spec in bodies
      res = append(res, @VisitMethodSpec(spec.(*parser.MethodSpecContext), delegate).(*MethodSpec))

    node.MethodSpecs = res

    return node

  VisitSliceType(ctx *parser.SliceTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &SliceType
      Node: NewNode(ctx)
      Type: @VisitElementType(ctx.ElementType().(*parser.ElementTypeContext), delegate).(*Type)

  VisitMapType(ctx *parser.MapTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &MapType
      Node: NewNode(ctx)
      InnerType:  @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)
      OuterType:  @VisitElementType(ctx.ElementType().(*parser.ElementTypeContext), delegate).(*Type)

  VisitChannelType(ctx *parser.ChannelTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &ChannelType
      Node: NewNode(ctx)
      ChannelDecl: ctx.ChannelDecl().GetText()
      Type: @VisitElementType(ctx.ElementType().(*parser.ElementTypeContext), delegate).(*Type)

  VisitMethodSpec(ctx *parser.MethodSpecContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &MethodSpec
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    if ctx.Parameters() != nil
      node.Parameters = @VisitParameters(ctx.Parameters().(*parser.ParametersContext), delegate).(*Parameters)

    if ctx.TypeName() != nil
      node.Type = ctx.TypeName().GetText()

    if ctx.Result() != nil
      node.Result = @VisitResult(ctx.Result().(*parser.ResultContext), delegate).(*Result)

    return node

  VisitFunctionType(ctx *parser.FunctionTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    return &FunctionType
      Node: NewNode(ctx)
      Signature: @VisitSignature(ctx.Signature().(*parser.SignatureContext), delegate).(*Signature)

  VisitSignature(ctx *parser.SignatureContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Signature
      Node: NewNode(ctx)

    if ctx.Parameters() != nil
      node.Parameters = @VisitParameters(ctx.Parameters().(*parser.ParametersContext), delegate).(*Parameters)

    if ctx.Result() != nil
      node.Result = @VisitResult(ctx.Result().(*parser.ResultContext), delegate).(*Result)

    return node

  VisitResult(ctx *parser.ResultContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Result
     Node: NewNode(ctx)

    res := []*Type{}

    bodies := ctx.AllType_()

    for _, spec in bodies
      res = append(res, @VisitType_(spec.(*parser.Type_Context), delegate).(*Type))

    node.Types = res

    return node

  VisitParameters(ctx *parser.ParametersContext, delegate antlr.ParseTreeVisitor): interface ->
    if ctx.ParameterList() != nil
      return @VisitParameterList(ctx.ParameterList().(*parser.ParameterListContext), delegate).(*Parameters)

    return &Parameters{}

  VisitParameterList(ctx *parser.ParameterListContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Parameters
      Node: NewNode(ctx)

    res := []*Parameter{}

    bodies := ctx.AllParameterDecl()

    for _, spec in bodies
      res = append(res, @VisitParameterDecl(spec.(*parser.ParameterDeclContext), delegate).(*Parameter))

    node.List = res

    return node

  VisitParameterDecl(ctx *parser.ParameterDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Parameter
      Node: NewNode(ctx)
      Names:  @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)
      Type:  @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)
      IsVariadic: ctx.RestOp() != nil

    return node

  VisitRestOp(ctx *parser.RestOpContext, delegate antlr.ParseTreeVisitor): interface ->
    return ctx.GetText()

  VisitOperand(ctx *parser.OperandContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Operand
      Node: NewNode(ctx)

    if ctx.Literal() != nil
      node.Literal = @VisitLiteral(ctx.Literal().(*parser.LiteralContext), delegate).(*Literal)

    if ctx.OperandName() != nil
      node.OperandName = @VisitOperandName(ctx.OperandName().(*parser.OperandNameContext), delegate).(*OperandName)

    if ctx.MethodExpr() != nil
      node.MethodExpr = @VisitMethodExpr(ctx.MethodExpr().(*parser.MethodExprContext), delegate).(*MethodExpr)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    return node

  VisitLiteral(ctx *parser.LiteralContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Literal
      Node: NewNode(ctx)

    if ctx.BasicLit() != nil
      node.Basic = @VisitBasicLit(ctx.BasicLit().(*parser.BasicLitContext), delegate).(string)

    if ctx.CompositeLit() != nil
      node.Composite = @VisitCompositeLit(ctx.CompositeLit().(*parser.CompositeLitContext), delegate).(*CompositeLit)

    return node

  VisitBasicLit(ctx *parser.BasicLitContext, delegate antlr.ParseTreeVisitor): interface ->
    return ctx.GetText()

  VisitOperandName(ctx *parser.OperandNameContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &OperandName
      Node: NewNode(ctx)

    if ctx.This_() != nil
      node.Name = "this"
    else if ctx.QualifiedIdent() != nil
      node.Name = @VisitQualifiedIdent(ctx.QualifiedIdent().(*parser.QualifiedIdentContext), delegate).(string)
    else
      node.Name = ctx.GetText()

    return node

  VisitThis_(ctx *parser.This_Context, delegate antlr.ParseTreeVisitor): interface ->
    return "this"

  VisitQualifiedIdent(ctx *parser.QualifiedIdentContext, delegate antlr.ParseTreeVisitor): interface ->
    if ctx.This_() != nil
      return "this." + ctx.IDENTIFIER(0).GetText()

    return ctx.IDENTIFIER(0).GetText() + "." + ctx.IDENTIFIER(1).GetText()

  VisitCompositeLit(ctx *parser.CompositeLitContext, delegate antlr.ParseTreeVisitor): interface ->
    return &CompositeLit
      Node: NewNode(ctx)
      LiteralType: @VisitLiteralType(ctx.LiteralType().(*parser.LiteralTypeContext), delegate).(*LiteralType)
      LiteralValue: @VisitLiteralValue(ctx.LiteralValue().(*parser.LiteralValueContext), delegate).(*LiteralValue)

  VisitLiteralType(ctx *parser.LiteralTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &LiteralType
      Node: NewNode(ctx)

    if ctx.StructType() != nil
      node.Struct = @VisitStructType(ctx.StructType().(*parser.StructTypeContext), delegate).(*StructType)

    if ctx.ArrayType() != nil
      node.Array = @VisitArrayType(ctx.ArrayType().(*parser.ArrayTypeContext), delegate).(*ArrayType)

    if ctx.ElementType() != nil
      node.Element = @VisitElementType(ctx.ElementType().(*parser.ElementTypeContext), delegate).(*Type)

    if ctx.SliceType() != nil
      node.Slice = @VisitSliceType(ctx.SliceType().(*parser.SliceTypeContext), delegate).(*SliceType)

    if ctx.MapType() != nil
      node.Map = @VisitMapType(ctx.MapType().(*parser.MapTypeContext), delegate).(*MapType)

    if ctx.TypeName() != nil
      node.Type = @VisitTypeName(ctx.TypeName().(*parser.TypeNameContext), delegate).(string)

    return node

  VisitLiteralValue(ctx *parser.LiteralValueContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &LiteralValue
      Node: NewNode(ctx)

    if ctx.ElementList() != nil
      node.Elements = @VisitElementList(ctx.ElementList().(*parser.ElementListContext), delegate).([]*KeyedElement)

    return node

  VisitElementList(ctx *parser.ElementListContext, delegate antlr.ParseTreeVisitor): interface ->
    res := []*KeyedElement{}

    bodies := ctx.AllKeyedElement()

    for _, spec in bodies
      res = append(res, @VisitKeyedElement(spec.(*parser.KeyedElementContext), delegate).(*KeyedElement))

    return res

  VisitKeyedElement(ctx *parser.KeyedElementContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &KeyedElement
      Node: NewNode(ctx)
      Element: @VisitElement(ctx.Element().(*parser.ElementContext), delegate).(*Element)

    if ctx.Key() != nil
      node.Key = @VisitKey(ctx.Key().(*parser.KeyContext), delegate).(*Key)

    return node

  VisitKey(ctx *parser.KeyContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Key
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.LiteralValue() != nil
      node.LiteralValue = @VisitLiteralValue(ctx.LiteralValue().(*parser.LiteralValueContext), delegate).(*LiteralValue)

    return node

  VisitElement(ctx *parser.ElementContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Element
      Node: NewNode(ctx)

    if ctx.Expression() != nil
      node.Expression = @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.LiteralValue() != nil
      node.LiteralValue = @VisitLiteralValue(ctx.LiteralValue().(*parser.LiteralValueContext), delegate).(*LiteralValue)

    return node

  VisitStructType(ctx *parser.StructTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &StructType
      Node: NewNode(ctx)

    if ctx.IDENTIFIER() != nil
      node.Name = ctx.IDENTIFIER().GetText()

    res := []*FieldDecl{}

    bodies := ctx.AllFieldDecl()

    for _, spec in bodies
      res = append(res, @VisitFieldDecl(spec.(*parser.FieldDeclContext), delegate).(*FieldDecl))

    node.Fields = res

    return node

  VisitFieldDecl(ctx *parser.FieldDeclContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &FieldDecl
      Node: NewNode(ctx)

    if ctx.IdentifierList() != nil
      node.Identifiers = @VisitIdentifierList(ctx.IdentifierList().(*parser.IdentifierListContext), delegate).([]string)

    if ctx.Type_() != nil
      node.Type = @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

    if ctx.AnonymousField() != nil
      node.Anonymous = @VisitAnonymousField(ctx.AnonymousField().(*parser.AnonymousFieldContext), delegate).(*AnonymousField)

    if ctx.STRING_LIT() != nil
      node.Tag = ctx.STRING_LIT().GetText()

    if ctx.InlineStructMethod() != nil
      node.InlineStructMethod = @VisitInlineStructMethod(ctx.InlineStructMethod().(*parser.InlineStructMethodContext), delegate).(*InlineStructMethod)

    return node

  VisitInlineStructMethod(ctx *parser.InlineStructMethodContext, delegate antlr.ParseTreeVisitor): interface ->
    return &InlineStructMethod
      Node: NewNode(ctx)
      FunctionDecl: @VisitFunctionDecl(ctx.FunctionDecl().(*parser.FunctionDeclContext), delegate).(*FunctionDecl)
      IsPointerReceiver: strings.Contains(ctx.GetText(), "*") // Warning here, can consume a `*` later in the stream

  VisitAnonymousField(ctx *parser.AnonymousFieldContext, delegate antlr.ParseTreeVisitor): interface ->
    return &AnonymousField
      Node: NewNode(ctx)
      Type: @VisitTypeName(ctx.TypeName().(*parser.TypeNameContext), delegate).(string)
      IsPointerReceiver: strings.Contains(ctx.GetText(), "*") // Warning here, can consume a `*` later in the stream

  VisitFunctionLit(ctx *parser.FunctionLitContext, delegate antlr.ParseTreeVisitor): interface ->
    return &FunctionLit
      Node: NewNode(ctx)
      Function: @VisitFunction(ctx.Function().(*parser.FunctionContext), delegate).(*Function)

  VisitPrimaryExpr(ctx *parser.PrimaryExprContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &PrimaryExpr
      Node: NewNode(ctx)

    if ctx.Operand() != nil
      node.Operand = @VisitOperand(ctx.Operand().(*parser.OperandContext), delegate).(*Operand)

    if ctx.Conversion() != nil
      node.Conversion = @VisitConversion(ctx.Conversion().(*parser.ConversionContext), delegate).(*Conversion)

    if ctx.PrimaryExpr() != nil
      node.PrimaryExpr = @VisitPrimaryExpr(ctx.PrimaryExpr().(*parser.PrimaryExprContext), delegate).(*PrimaryExpr)

    if ctx.Selector() != nil
      node.Selector = @VisitSelector(ctx.Selector().(*parser.SelectorContext), delegate).(string)

    if ctx.Index() != nil
      node.Index = @VisitIndex(ctx.Index().(*parser.IndexContext), delegate).(*Index)

    if ctx.Slice() != nil
      node.Slice = @VisitSlice(ctx.Slice().(*parser.SliceContext), delegate).(*Slice)

    if ctx.TypeAssertion() != nil
      node.TypeAssertion = @VisitTypeAssertion(ctx.TypeAssertion().(*parser.TypeAssertionContext), delegate).(*TypeAssertion)

    if ctx.Arguments() != nil
      node.Arguments = @VisitArguments(ctx.Arguments().(*parser.ArgumentsContext), delegate).(*Arguments)

    return node

  VisitSelector(ctx *parser.SelectorContext, delegate antlr.ParseTreeVisitor): interface ->
    return "." + ctx.IDENTIFIER().GetText()

  VisitIndex(ctx *parser.IndexContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Index
      Node: NewNode(ctx)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)

  VisitSlice(ctx *parser.SliceContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Slice
      Node: NewNode(ctx)

    dist := strings.Split(ctx.GetText(), ":")

    if len(dist) == 3
      if len(dist[0]) <= 1
        node.RightExpr = @VisitExpression(ctx.Expression(1).(*parser.ExpressionContext), delegate).(*Expression)
        node.MiddleExpr = @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)
      else
        node.RightExpr = @VisitExpression(ctx.Expression(2).(*parser.ExpressionContext), delegate).(*Expression)
        node.MiddleExpr = @VisitExpression(ctx.Expression(1).(*parser.ExpressionContext), delegate).(*Expression)
        if ctx.Expression(0) != nil
          node.LeftExpr = @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)
    else
      if len(dist[0]) <= 1
        if ctx.Expression(0) != nil
          node.MiddleExpr = @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)
      else
        if ctx.Expression(0) != nil
          node.LeftExpr = @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)
        if ctx.Expression(1) != nil
          node.MiddleExpr = @VisitExpression(ctx.Expression(1).(*parser.ExpressionContext), delegate).(*Expression)



    return node

  VisitTypeAssertion(ctx *parser.TypeAssertionContext, delegate antlr.ParseTreeVisitor): interface ->
    return &TypeAssertion
      Node: NewNode(ctx)
      Type: @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

  VisitArguments(ctx *parser.ArgumentsContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Arguments
      Node: NewNode(ctx)
      IsVariadic: ctx.RestOp() != nil

    if ctx.Type_() != nil
      node.Type = @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)

    if ctx.ExpressionList() != nil
      node.Expressions = @VisitExpressionList(ctx.ExpressionList().(*parser.ExpressionListContext), delegate).(*ExpressionList)

    return node

  VisitMethodExpr(ctx *parser.MethodExprContext, delegate antlr.ParseTreeVisitor): interface ->
    return &MethodExpr
      Node: NewNode(ctx)
      ReceiverType: @VisitReceiverType(ctx.ReceiverType().(*parser.ReceiverTypeContext), delegate).(*ReceiverType)
      Name: ctx.IDENTIFIER().GetText()

  VisitReceiverType(ctx *parser.ReceiverTypeContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &ReceiverType
      Node: NewNode(ctx)
      IsPointer: strings.Contains(ctx.GetText(), "*")

    if ctx.TypeName() != nil
      node.Type = @VisitTypeName(ctx.TypeName().(*parser.TypeNameContext), delegate).(string)

    if ctx.ReceiverType() != nil
      node.ReceiverType = @VisitReceiverType(ctx.ReceiverType().(*parser.ReceiverTypeContext), delegate).(*ReceiverType)

    return node

  VisitExpression(ctx *parser.ExpressionContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Expression
      Node: NewNode(ctx)

    if ctx.UnaryExpr() != nil
      node.UnaryExpr = @VisitUnaryExpr(ctx.UnaryExpr().(*parser.UnaryExprContext), delegate).(*UnaryExpr)

    if ctx.FunctionLit() != nil
      node.FunctionLit = @VisitFunctionLit(ctx.FunctionLit().(*parser.FunctionLitContext), delegate).(*FunctionLit)

    if ctx.Expression(0) != nil
      node.LeftExpression = @VisitExpression(ctx.Expression(0).(*parser.ExpressionContext), delegate).(*Expression)

    if ctx.Binary_op() != nil
      node.Op = ctx.Binary_op().GetText()

    if ctx.Expression(1) != nil
      node.RightExpression = @VisitExpression(ctx.Expression(1).(*parser.ExpressionContext), delegate).(*Expression)

    return node

  VisitUnaryExpr(ctx *parser.UnaryExprContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &UnaryExpr
      Node: NewNode(ctx)

    if ctx.PrimaryExpr() != nil
      node.PrimaryExpr = @VisitPrimaryExpr(ctx.PrimaryExpr().(*parser.PrimaryExprContext), delegate).(*PrimaryExpr)

    if ctx.Unary_op() != nil
      node.Op = ctx.Unary_op().GetText()

    if ctx.UnaryExpr() != nil
      node.UnaryExpr = @VisitUnaryExpr(ctx.UnaryExpr().(*parser.UnaryExprContext), delegate).(*UnaryExpr)

    return node

  VisitUnary_op(ctx *parser.Unary_opContext, delegate antlr.ParseTreeVisitor): interface ->
    return ctx.GetText()

  VisitConversion(ctx *parser.ConversionContext, delegate antlr.ParseTreeVisitor): interface ->
    return &Conversion
      Node: NewNode(ctx)
      Type: @VisitType_(ctx.Type_().(*parser.Type_Context), delegate).(*Type)
      Expression: @VisitExpression(ctx.Expression().(*parser.ExpressionContext), delegate).(*Expression)


  // VisitEos(ctx *parser.EosContext, delegate antlr.ParseTreeVisitor): interface ->
  //   if ctx.EOF() != nil || ctx.GetText() == ";"
  //     return "\n"

  //   return ""

  VisitInterp(ctx *parser.InterpContext, delegate antlr.ParseTreeVisitor): interface ->
    node := &Interpret
      Node:          NewNode(ctx)

    if ctx.Statement() != nil
      node.Statement = @VisitStatement(ctx.Statement().(*parser.StatementContext), delegate).(*Statement)

    if ctx.TopLevelDecl() != nil
      node.TopLevel = @VisitTopLevelDecl(ctx.TopLevelDecl().(*parser.TopLevelDeclContext), delegate).(*TopLevel)

    return node
